# CLAUDE.md

> **READ FIRST:** Before proceeding with any task, read `.claude/why.md` to understand why this project exists.

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a **Market Simulator** project that implements technical analysis algorithms for detecting market structure and generating realistic OHLC price data.

**Current phase:** Swing detection rewrite with hierarchical model.

For detailed architecture and current status, see `Docs/State/architect_notes.md`.

## Development Commands

### Virtual Environment
This project uses a Python virtual environment located in `venv/`. Always activate it before working:
```bash
source venv/bin/activate
```

### Testing
```bash
source venv/bin/activate && python -m pytest tests/ -v
```

## Architecture Overview

For detailed technical architecture, see `Docs/State/architect_notes.md`.

### Source Modules

| Module | Purpose |
|--------|---------|
| `src/swing_analysis/` | Core detection: HierarchicalDetector, SwingNode, ReferenceFrame, BarAggregator |
| `src/data/` | OHLC data loading and gap detection |

### Key Components

- **HierarchicalDetector** (`swing_analysis/hierarchical_detector.py`) - Incremental swing detection with hierarchical model
- **BarAggregator** (`swing_analysis/bar_aggregator.py`) - Multi-timeframe OHLC aggregation
- **SwingNode** (`swing_analysis/swing_node.py`) - Hierarchical swing data structure

### Design Principles

- **Hierarchical**: Tree-structured swings with parent-child relationships
- **Fibonacci levels**: 0.382, 0.5, 0.618, 1.0, 1.382, 1.5, 1.618, 2.0 ratios
- **Resolution-agnostic**: Supports 1m, 5m, 15m, 30m, 1h, 4h, 1d source data
- **Performance**: <60s for 6M bars

## File Structure

```
src/
├── swing_analysis/            # Core detection algorithms
└── data/                      # OHLC loading

Docs/
├── State/      # Current state: architect_notes.md, product_direction.md, pending_review.md
├── Comms/      # Inter-role questions: questions.md, archive.md
├── Reference/  # Long-lived: user_guide.md, developer_guide.md, interview_notes.md
├── Working/    # Active one-off artifacts (proposals, explorations) → Archive when done
├── Prompts/    # Agent prompt templates (reusable)
└── Archive/    # Historical content by topic

tests/          # 600+ tests
```

## Data Files

The `test_data/es-*.csv` files use a non-standard format:

| Aspect | Format |
|--------|--------|
| Delimiter | Semicolon (`;`) |
| Header | None |
| Columns | date;time;open;high;low;close;volume |
| Date format | `dd/mm/yyyy` |
| Time format | `HH:MM:SS` (EDT/EST) |

**Example row:**
```
01/04/2007;17:30:00;1431;1431.5;1430.25;1430.5;725
```

## Development Guidelines

### Dependencies
Core dependencies:
- **matplotlib** - Visualization and charting
- **numpy** - Numerical computations
- **pandas** - Data manipulation (legacy components)
- **pytest** - Testing framework

### Performance Targets
- **Analysis**: <60s for 6M bars (achieved)
- **Memory**: Stable usage during long sessions

### Testing Strategy
- **Unit tests**: Component isolation with mocked dependencies
- **Integration tests**: Cross-component data flow validation  
- **Performance tests**: Latency and memory benchmarks
- **Real-world data**: Validation against historical market data

### Code Quality Standards
- Type hints throughout the codebase
- Comprehensive error handling with graceful degradation
- Detailed docstrings with usage examples
- Configuration-driven behavior for flexibility

### Attribution
Do NOT add "Generated by Claude Code", "Co-Authored-By: Claude Opus", or similar signatures to commits, documents, or code. This is redundant—if no human engineer is identified, Claude Code is assumed.

## Issue Resolution Workflow

When resolving GitHub issues, follow this structured process:

### 1. Investigation
- Read the issue thoroughly on GitHub (`gh issue view <number>`)
- Explore relevant code using Grep, Glob, and Read tools
- Understand the root cause before implementing

### 2. Implementation
- Make focused changes that directly address the issue
- Follow existing code patterns and style
- Add type hints and docstrings for new code

### 3. Testing
- **Write tests** for new functionality or bug fixes
- Run the test suite to verify no regressions:
  ```bash
  source venv/bin/activate && python -m pytest tests/ -v
  ```
- For visualization/GUI changes, manually verify the fix works
- Ensure all relevant tests pass before proceeding

### 4. Commit and Push
- Stage only relevant files (avoid `.DS_Store`, `__pycache__`, etc.)
- Write descriptive commit messages:
  ```bash
  git commit -m "$(cat <<'EOF'
  Brief summary of change (fixes #<issue>)

  - Bullet point details of what changed
  - Why it was changed
  - Any notable implementation decisions
  EOF
  )"
  ```

### 5. Close Issue with Summary
- Close the issue with a detailed comment explaining the fix:
  ```bash
  gh issue close <number> --comment "Fixed in commit <hash>.

  **Summary:**
  - What was the root cause
  - What changes were made
  - How to verify the fix

  **Files changed:**
  - path/to/file.py - description of change"
  ```

### 6. Document in GitHub Issue
Add a comment to the GitHub issue with implementation notes:
- What was the root cause
- What changes were made and why
- Any gotchas or design decisions

### 7. Update User Documentation (if applicable)
If the change affects user-facing functionality:
- Update `Docs/Reference/user_guide.md`
- Add examples showing how to use new features

### 8. Update Pending Review
Update `Docs/State/pending_review.md`:
- Increment the unreviewed change count
- Add the issue number to the list

### Checklist Summary
- [ ] Issue understood and root cause identified
- [ ] Fix implemented following code standards
- [ ] Tests written and passing
- [ ] Commit pushed with descriptive message
- [ ] Issue closed with summary comment
- [ ] Implementation notes added to GitHub issue
- [ ] User guide updated (if user-facing changes)
- [ ] `Docs/State/pending_review.md` updated

## Epic Filing Workflow

When filing epics (multi-issue features), structure them as follows:

### Sub-Issue Structure
- Create sub-issues for each distinct concern
- Each sub-issue should be completable and testable independently
- Engineer agent completes and tests each sub-issue in turn

### Required Sub-Issues
Every epic must include a documentation sub-issue:
- Update `Docs/Reference/DAG.md` for changes to DAG behavior
- Update `Docs/Reference/developer_guide.md` for implementation/architecture changes
- Update `Docs/Reference/user_guide.md` for user-facing changes

### Commit Strategy
- All sub-issues should be committed and pushed in one atomic operation at the end
- The final sub-issue should instruct: "Commit all changes and push"

### Parallelism
- If the epic is too large for one agent session, explicitly call out sequential execution requirements
- Sub-issues that can be worked in parallel should be marked: "Can be parallelized with #NNN"
- Sub-issues requiring sequential execution should be marked: "Requires #NNN to be completed first"
- If no sequential dependency is noted, agents may work sub-issues in parallel and commit individually

## Usage Patterns

See `Docs/Reference/user_guide.md` for detailed usage instructions.

### Quick Start
```bash
# Run tests
source venv/bin/activate && python -m pytest tests/ -v
```

### Development Workflows
1. **Testing changes**: Run `python -m pytest tests/ -v` before commits
2. **Adding features**: Update both implementation and tests
3. **Issue workflow**: See "Issue Resolution Workflow" section below

## Current Development Phase

**Current:** Swing detection rewrite — replacing S/M/L/XL model with hierarchical tree structure.

See `Docs/State/architect_notes.md` for detailed status and `Docs/State/product_direction.md` for requirements.

**Active issues:** #141 (epic), #142-#146 (foundation tasks)

## Role-Based Workflows

This project uses persona-based workflows. When asked to work as a specific role:

1. Read `.claude/personas/[role].md` first
2. Follow the workflow defined there
3. Update appropriate artifacts per handoff protocol

| Invocation | Persona | Primary Output |
|------------|---------|----------------|
| "As engineer..." | Engineer | GitHub issues + code |
| "As architect..." | Architect | `Docs/State/architect_notes.md` |
| "As product..." | Product | `Docs/State/product_direction.md` |
| "As director..." | Director | `.claude/personas/*` |

**Docs Structure:**
```
Docs/
├── State/       # Current state (single files, overwrite)
├── Comms/       # Cross-role questions
├── Reference/   # Long-lived docs (north star, user guide, interviews)
├── Working/     # Active one-off artifacts → Archive when done
├── Prompts/     # Agent prompt templates (reusable)
└── Archive/     # Historical content by topic
```

**Role Recognition:**
- Match liberally: "product manager", "PM", "product" → Product persona
- Variants like "as an architect", "from engineering perspective" → match the role keyword
- **When ambiguous, assume the role** and state it explicitly rather than proceeding without a persona
- If uncertain which role fits, ask before proceeding

See `.claude/CLAUDE_ADDENDUM.md` for full protocol.

## Available Skills

Skills in `.claude/skills/` are invoked with "Use the X skill" or `/skill_name`:

| Skill | When to Use |
|-------|-------------|
| handoff | After completing any task, to transfer to next persona |
| doc_update | After code changes, to update reference docs |
| push_changes | After implementation complete, to commit and push |
| file_issue | When discovering bugs or proposing features |
| diagnose_feedback | When user says "look at my feedback" or similar |
| interview | Interview user to complete a spec (`/interview <spec-name>`) |
| finish | End-of-task orchestrator (`/finish`) — runs doc_update, file_issue, push_changes, handoff as needed |
